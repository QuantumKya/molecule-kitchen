
let CURRENTFRAME = 0;
const FPS = 30;

function getCurrentFrame() { return CURRENTFRAME; }


let currentMousePos = new Victor(0, 0);

function getMousePos() { return currentMousePos.clone(); }


let SHIFTING = false;
let CTRLING = false;


const atoms = {
    hydrogen: {
        symbol: 'H',
        valence: 1,
        color: '#ffffff',
    },
    carbon: {
        symbol: 'C',
        valence: 4,
        color: '#000000',
    },
    nitrogen: {
        symbol: 'N',
        valence: 3,
        color: '#3434d5ff',
    },
    oxygen: {
        symbol: 'O',
        valence: 2,
        color: '#c41313ff',
    },
    sodium: {
        symbol: 'Na',
        valence: 7,
    },
    phosphorus: {
        symbol: 'P',
        valence: 3
    },
    chlorine: {
        symbol: 'Cl',
        valence: 1,
    },
    potassium: {
        symbol: 'K',
        valence: 17,
    },
};





// I got this function from a Medium article; https://colton-shawn-oconnor.medium.com/changing-text-color-based-on-the-background-in-javascript-947bf9bc136b
function getBrightness(r, g, b) {
    return (r * 299 + g * 587 + b * 114) / 1000;
}

// this particular function was generated by Gemini :sob: nothing else is though
// I did add the part accounting for alpha values myself
function RGBFromHex(hex) {
    // Remove '#' if present
    hex = hex.startsWith('#') ? hex.slice(1) : hex;

    // Handle shorthand hex codes (e.g., #FFF)
    if (hex.length === 3) {
        hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
    }

    // Ensure it's a valid 6-digit hex code
    if (!/^[0-9A-Fa-f]{6}$/.test(hex) && !/^[0-9A-Fa-f]{8}$/.test(hex)) {
        console.error("Invalid hex code:", hex);
        return null;
    }
    
    
    const r = parseInt(hex.slice(0, 2), 16);
    const g = parseInt(hex.slice(2, 4), 16);
    const b = parseInt(hex.slice(4, 6), 16);

    const a = (/^[0-9A-Fa-f]{8}$/.test(hex)) ? parseInt(hex.slice(6, 8), 16) : 255;

    return { r, g, b, a };
}

function hexFromRGB(r, g, b, a = 255) {
    const rhex = r.toString(16).padStart(2, '0');
    const ghex = g.toString(16).padStart(2, '0');
    const bhex = b.toString(16).padStart(2, '0');
    const ahex = a.toString(16).padStart(2, '0');
    return '#'+ rhex + ghex + bhex + ahex;
}

function darkenColor(hex, darkFactor) {
    const rgb = RGBFromHex(hex);
    rgb.r = Math.round(rgb.r * darkFactor);
    rgb.g = Math.round(rgb.g * darkFactor);
    rgb.b = Math.round(rgb.b * darkFactor);
    return hexFromRGB(rgb.r, rgb.g, rgb.b, rgb.a);
}

function getTextColorFromBG(hex) {
    const rgb = RGBFromHex(hex);
    const br = getBrightness(rgb.r, rgb.g, rgb.b);

    return (br >= 150) ? '#000000' : '#FFFFFF';
}



function polarLerp(start, target, t, center = new Victor(0, 0), counterclockwise = true) {
    const st = start.clone().subtract(center);
    const tg = target.clone().subtract(center);
    
    const stangle = st.angle();
    let tgangle = tg.angle();

    let deltangle = tgangle - stangle;
    deltangle = ((deltangle + Math.PI) % (2 * Math.PI)) - Math.PI;

    if (counterclockwise && deltangle < 0) deltangle += 2 * Math.PI;
    if (!counterclockwise && deltangle > 0) deltangle -= 2 * Math.PI;

    const lerpangle = stangle + deltangle * t;

    const strad = st.length();
    const tgrad = tg.length();

    const lerprad = (1-t)*strad + t*tgrad;

    return new Victor(Math.cos(lerpangle), Math.sin(lerpangle)).multiplyScalar(lerprad).add(center);
}

function polarVec(angle, radius) {
    return new Victor(Math.cos(angle), Math.sin(angle)).multiplyScalar(radius);
}

function roundToInterval(value, interval) {
    return Math.round(value / interval) * interval;
}

function clampToAngleSpace(angle) {
    return (angle + Math.PI) % (Math.PI * 2) - Math.PI;
}